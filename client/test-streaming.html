<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test gRPC Streaming over IPC</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 {
            color: #333;
        }
        .section {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .output {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        .message {
            padding: 4px 0;
            border-bottom: 1px solid #e9ecef;
        }
        .message:last-child {
            border-bottom: none;
        }
        .error {
            color: #dc3545;
        }
        .success {
            color: #28a745;
        }
        .info {
            color: #17a2b8;
        }
        input[type="text"] {
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            width: 300px;
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <h1>Test gRPC Streaming over IPC</h1>

    <div class="section">
        <h2>Unary Calls</h2>
        <button onclick="testUnaryCall()">Test GetWorkspaceInfo</button>
        <button onclick="testListTargets()">Test ListTargets</button>
        <div id="unary-output" class="output"></div>
    </div>

    <div class="section">
        <h2>Streaming Calls</h2>
        <div>
            <input type="text" id="query-input" placeholder="Enter Bazel query (e.g., //...)" value="//...">
            <button onclick="testStreamQuery()">Test StreamQuery</button>
        </div>
        <div>
            <input type="text" id="target-input" placeholder="Enter target to build" value="//app:build">
            <button onclick="testStreamBuild()">Test StreamBuild</button>
        </div>
        <button id="abort-stream" onclick="abortStream()" disabled>Abort Stream</button>
        <div id="stream-output" class="output"></div>
    </div>

    <script type="module">
        // Import the IPC client
        import { createGazelServiceClient } from './client.ipc.js';
        import { createClient } from '@connectrpc/connect';
        import { create } from '@bufbuild/protobuf';
        import { 
            GetWorkspaceInfoRequestSchema,
            ListTargetsRequestSchema,
            StreamQueryRequestSchema,
            StreamBuildRequestSchema
        } from '../proto/gazel_pb.js';

        // Make functions available globally for onclick handlers
        window.testUnaryCall = async function() {
            const output = document.getElementById('unary-output');
            output.innerHTML = '';
            
            try {
                addMessage(output, 'Calling GetWorkspaceInfo...', 'info');
                
                // Create request
                const request = create(GetWorkspaceInfoRequestSchema, {});
                
                // Make unary call through IPC
                const response = await window.electron.ipcRenderer.invoke('grpc:unary:request', {
                    method: 'GetWorkspaceInfo',
                    service: 'GazelService',
                    data: request
                });
                
                addMessage(output, 'Response received:', 'success');
                addMessage(output, JSON.stringify(response, null, 2));
            } catch (error) {
                addMessage(output, `Error: ${error.message}`, 'error');
            }
        };

        window.testListTargets = async function() {
            const output = document.getElementById('unary-output');
            output.innerHTML = '';
            
            try {
                addMessage(output, 'Calling ListTargets...', 'info');
                
                // Create request
                const request = create(ListTargetsRequestSchema, {
                    pattern: '//...',
                    format: 'label_kind'
                });
                
                // Make unary call through IPC
                const response = await window.electron.ipcRenderer.invoke('grpc:unary:request', {
                    method: 'ListTargets',
                    service: 'GazelService',
                    data: request
                });
                
                addMessage(output, 'Response received:', 'success');
                addMessage(output, `Total targets: ${response.total || 0}`);
                if (response.targets && response.targets.length > 0) {
                    addMessage(output, 'First 10 targets:');
                    response.targets.slice(0, 10).forEach(target => {
                        addMessage(output, `  - ${target.label} (${target.kind})`);
                    });
                }
            } catch (error) {
                addMessage(output, `Error: ${error.message}`, 'error');
            }
        };

        let currentStreamId = null;

        window.testStreamQuery = async function() {
            const output = document.getElementById('stream-output');
            const query = document.getElementById('query-input').value;
            output.innerHTML = '';
            
            if (!query) {
                addMessage(output, 'Please enter a query', 'error');
                return;
            }
            
            try {
                addMessage(output, `Starting StreamQuery with query: ${query}`, 'info');
                
                // Generate stream ID
                currentStreamId = `stream-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
                
                // Set up listeners for stream messages
                const messageChannel = `grpc:stream:message:${currentStreamId}`;
                const errorChannel = `grpc:stream:error:${currentStreamId}`;
                const completeChannel = `grpc:stream:complete:${currentStreamId}`;
                
                let messageCount = 0;
                
                // Listen for messages
                window.electron.ipcRenderer.on(messageChannel, (data) => {
                    messageCount++;
                    addMessage(output, `Message ${messageCount}: ${JSON.stringify(data)}`, 'success');
                });
                
                // Listen for errors
                window.electron.ipcRenderer.on(errorChannel, (error) => {
                    addMessage(output, `Stream error: ${error}`, 'error');
                    document.getElementById('abort-stream').disabled = true;
                });
                
                // Listen for completion
                window.electron.ipcRenderer.on(completeChannel, () => {
                    addMessage(output, `Stream completed. Total messages: ${messageCount}`, 'info');
                    document.getElementById('abort-stream').disabled = true;
                    currentStreamId = null;
                });
                
                // Enable abort button
                document.getElementById('abort-stream').disabled = false;
                
                // Create request
                const request = create(StreamQueryRequestSchema, {
                    query: query,
                    outputFormat: 'label_kind'
                });
                
                // Start the stream
                await window.electron.ipcRenderer.invoke('grpc:stream:start', {
                    streamId: currentStreamId,
                    method: 'StreamQuery',
                    service: 'GazelService',
                    data: [request]
                });
                
                addMessage(output, 'Stream started successfully', 'success');
            } catch (error) {
                addMessage(output, `Error starting stream: ${error.message}`, 'error');
                document.getElementById('abort-stream').disabled = true;
            }
        };

        window.testStreamBuild = async function() {
            const output = document.getElementById('stream-output');
            const target = document.getElementById('target-input').value;
            output.innerHTML = '';
            
            if (!target) {
                addMessage(output, 'Please enter a target', 'error');
                return;
            }
            
            try {
                addMessage(output, `Starting StreamBuild for target: ${target}`, 'info');
                
                // Generate stream ID
                currentStreamId = `stream-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
                
                // Set up listeners for stream messages
                const messageChannel = `grpc:stream:message:${currentStreamId}`;
                const errorChannel = `grpc:stream:error:${currentStreamId}`;
                const completeChannel = `grpc:stream:complete:${currentStreamId}`;
                
                // Listen for messages
                window.electron.ipcRenderer.on(messageChannel, (data) => {
                    if (data.event) {
                        const eventType = data.event.case;
                        const eventValue = data.event.value;
                        addMessage(output, `[${eventType}] ${eventValue}`, eventType === 'error' ? 'error' : 'success');
                    } else {
                        addMessage(output, JSON.stringify(data), 'success');
                    }
                });
                
                // Listen for errors
                window.electron.ipcRenderer.on(errorChannel, (error) => {
                    addMessage(output, `Stream error: ${error}`, 'error');
                    document.getElementById('abort-stream').disabled = true;
                });
                
                // Listen for completion
                window.electron.ipcRenderer.on(completeChannel, () => {
                    addMessage(output, 'Build stream completed', 'info');
                    document.getElementById('abort-stream').disabled = true;
                    currentStreamId = null;
                });
                
                // Enable abort button
                document.getElementById('abort-stream').disabled = false;
                
                // Create request
                const request = create(StreamBuildRequestSchema, {
                    target: target,
                    options: []
                });
                
                // Start the stream
                await window.electron.ipcRenderer.invoke('grpc:stream:start', {
                    streamId: currentStreamId,
                    method: 'StreamBuild',
                    service: 'GazelService',
                    data: [request]
                });
                
                addMessage(output, 'Build stream started successfully', 'success');
            } catch (error) {
                addMessage(output, `Error starting stream: ${error.message}`, 'error');
                document.getElementById('abort-stream').disabled = true;
            }
        };

        window.abortStream = function() {
            if (currentStreamId) {
                window.electron.ipcRenderer.send('grpc:stream:abort', currentStreamId);
                addMessage(document.getElementById('stream-output'), 'Stream abort requested', 'info');
                document.getElementById('abort-stream').disabled = true;
            }
        };

        function addMessage(container, message, className = '') {
            const div = document.createElement('div');
            div.className = 'message ' + className;
            div.textContent = message;
            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
        }
    </script>
</body>
</html>
