// Copyright 2014 The Bazel Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// This file contains the protocol buffer representation of a build
// file or 'blaze query --output=proto' call.

// @generated by protoc-gen-es v2.9.0 with parameter "target=ts,import_extension=js"
// @generated from file build.proto (package blaze_query, syntax proto2)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { RuleInfo } from "./stardoc_output_pb.js";
import { file_stardoc_output } from "./stardoc_output_pb.js";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file build.proto.
 */
export const file_build: GenFile = /*@__PURE__*/
  fileDesc("CgtidWlsZC5wcm90bxILYmxhemVfcXVlcnkiMgoHTGljZW5zZRIUCgxsaWNlbnNlX3R5cGUYASADKAkSEQoJZXhjZXB0aW9uGAIgAygJIi0KD1N0cmluZ0RpY3RFbnRyeRILCgNrZXkYASACKAkSDQoFdmFsdWUYAiACKAkiMQoTTGFiZWxEaWN0VW5hcnlFbnRyeRILCgNrZXkYASACKAkSDQoFdmFsdWUYAiACKAkiMAoSTGFiZWxMaXN0RGljdEVudHJ5EgsKA2tleRgBIAIoCRINCgV2YWx1ZRgCIAMoCSI3ChlMYWJlbEtleWVkU3RyaW5nRGljdEVudHJ5EgsKA2tleRgBIAIoCRINCgV2YWx1ZRgCIAIoCSIxChNTdHJpbmdMaXN0RGljdEVudHJ5EgsKA2tleRgBIAIoCRINCgV2YWx1ZRgCIAMoCSKCAgoMRmlsZXNldEVudHJ5Eg4KBnNvdXJjZRgBIAIoCRIdChVkZXN0aW5hdGlvbl9kaXJlY3RvcnkYAiACKAkSFQoNZmlsZXNfcHJlc2VudBgHIAEoCBIMCgRmaWxlGAMgAygJEg8KB2V4Y2x1ZGUYBCADKAkSSQoQc3ltbGlua19iZWhhdmlvchgFIAEoDjIpLmJsYXplX3F1ZXJ5LkZpbGVzZXRFbnRyeS5TeW1saW5rQmVoYXZpb3I6BENPUFkSFAoMc3RyaXBfcHJlZml4GAYgASgJIiwKD1N5bWxpbmtCZWhhdmlvchIICgRDT1BZEAESDwoLREVSRUZFUkVOQ0UQAiLEEQoJQXR0cmlidXRlEgwKBG5hbWUYASACKAkSHAoUZXhwbGljaXRseV9zcGVjaWZpZWQYDSABKAgSDQoFbm9kZXAYFCABKAgSGgoSc291cmNlX2FzcGVjdF9uYW1lGBcgASgJEjIKBHR5cGUYAiACKA4yJC5ibGF6ZV9xdWVyeS5BdHRyaWJ1dGUuRGlzY3JpbWluYXRvchIRCglpbnRfdmFsdWUYAyABKAUSFAoMc3RyaW5nX3ZhbHVlGAUgASgJEhUKDWJvb2xlYW5fdmFsdWUYDiABKAgSNwoOdHJpc3RhdGVfdmFsdWUYDyABKA4yHy5ibGF6ZV9xdWVyeS5BdHRyaWJ1dGUuVHJpc3RhdGUSGQoRc3RyaW5nX2xpc3RfdmFsdWUYBiADKAkSJQoHbGljZW5zZRgHIAEoCzIULmJsYXplX3F1ZXJ5LkxpY2Vuc2USNwoRc3RyaW5nX2RpY3RfdmFsdWUYCCADKAsyHC5ibGF6ZV9xdWVyeS5TdHJpbmdEaWN0RW50cnkSNQoSZmlsZXNldF9saXN0X3ZhbHVlGAkgAygLMhkuYmxhemVfcXVlcnkuRmlsZXNldEVudHJ5Ej4KFWxhYmVsX2xpc3RfZGljdF92YWx1ZRgKIAMoCzIfLmJsYXplX3F1ZXJ5LkxhYmVsTGlzdERpY3RFbnRyeRJAChZzdHJpbmdfbGlzdF9kaWN0X3ZhbHVlGAsgAygLMiAuYmxhemVfcXVlcnkuU3RyaW5nTGlzdERpY3RFbnRyeRIWCg5pbnRfbGlzdF92YWx1ZRgRIAMoBRJAChZsYWJlbF9kaWN0X3VuYXJ5X3ZhbHVlGBMgAygLMiAuYmxhemVfcXVlcnkuTGFiZWxEaWN0VW5hcnlFbnRyeRJNCh1sYWJlbF9rZXllZF9zdHJpbmdfZGljdF92YWx1ZRgWIAMoCzImLmJsYXplX3F1ZXJ5LkxhYmVsS2V5ZWRTdHJpbmdEaWN0RW50cnkSOgoNc2VsZWN0b3JfbGlzdBgVIAEoCzIjLmJsYXplX3F1ZXJ5LkF0dHJpYnV0ZS5TZWxlY3Rvckxpc3QSKgoiREVQUkVDQVRFRF9zdHJpbmdfZGljdF91bmFyeV92YWx1ZRgSIAMoDBrABQoNU2VsZWN0b3JFbnRyeRINCgVsYWJlbBgBIAEoCRIYChBpc19kZWZhdWx0X3ZhbHVlGBAgASgIEhEKCWludF92YWx1ZRgCIAEoBRIUCgxzdHJpbmdfdmFsdWUYAyABKAkSFQoNYm9vbGVhbl92YWx1ZRgEIAEoCBI3Cg50cmlzdGF0ZV92YWx1ZRgFIAEoDjIfLmJsYXplX3F1ZXJ5LkF0dHJpYnV0ZS5UcmlzdGF0ZRIZChFzdHJpbmdfbGlzdF92YWx1ZRgGIAMoCRIlCgdsaWNlbnNlGAcgASgLMhQuYmxhemVfcXVlcnkuTGljZW5zZRI3ChFzdHJpbmdfZGljdF92YWx1ZRgIIAMoCzIcLmJsYXplX3F1ZXJ5LlN0cmluZ0RpY3RFbnRyeRI1ChJmaWxlc2V0X2xpc3RfdmFsdWUYCSADKAsyGS5ibGF6ZV9xdWVyeS5GaWxlc2V0RW50cnkSPgoVbGFiZWxfbGlzdF9kaWN0X3ZhbHVlGAogAygLMh8uYmxhemVfcXVlcnkuTGFiZWxMaXN0RGljdEVudHJ5EkAKFnN0cmluZ19saXN0X2RpY3RfdmFsdWUYCyADKAsyIC5ibGF6ZV9xdWVyeS5TdHJpbmdMaXN0RGljdEVudHJ5EhYKDmludF9saXN0X3ZhbHVlGA0gAygFEkAKFmxhYmVsX2RpY3RfdW5hcnlfdmFsdWUYDyADKAsyIC5ibGF6ZV9xdWVyeS5MYWJlbERpY3RVbmFyeUVudHJ5Ek0KHWxhYmVsX2tleWVkX3N0cmluZ19kaWN0X3ZhbHVlGBEgAygLMiYuYmxhemVfcXVlcnkuTGFiZWxLZXllZFN0cmluZ0RpY3RFbnRyeRIqCiJERVBSRUNBVEVEX3N0cmluZ19kaWN0X3VuYXJ5X3ZhbHVlGA4gAygMSgQIDBANGnQKCFNlbGVjdG9yEjUKB2VudHJpZXMYASADKAsyJC5ibGF6ZV9xdWVyeS5BdHRyaWJ1dGUuU2VsZWN0b3JFbnRyeRIZChFoYXNfZGVmYXVsdF92YWx1ZRgCIAEoCBIWCg5ub19tYXRjaF9lcnJvchgDIAEoCRp1CgxTZWxlY3Rvckxpc3QSMgoEdHlwZRgBIAEoDjIkLmJsYXplX3F1ZXJ5LkF0dHJpYnV0ZS5EaXNjcmltaW5hdG9yEjEKCGVsZW1lbnRzGAIgAygLMh8uYmxhemVfcXVlcnkuQXR0cmlidXRlLlNlbGVjdG9yIooDCg1EaXNjcmltaW5hdG9yEgsKB0lOVEVHRVIQARIKCgZTVFJJTkcQAhIJCgVMQUJFTBADEgoKBk9VVFBVVBAEEg8KC1NUUklOR19MSVNUEAUSDgoKTEFCRUxfTElTVBAGEg8KC09VVFBVVF9MSVNUEAcSFAoQRElTVFJJQlVUSU9OX1NFVBAIEgsKB0xJQ0VOU0UQCRIPCgtTVFJJTkdfRElDVBAKEhYKEkZJTEVTRVRfRU5UUllfTElTVBALEhMKD0xBQkVMX0xJU1RfRElDVBAMEhQKEFNUUklOR19MSVNUX0RJQ1QQDRILCgdCT09MRUFOEA4SDAoIVFJJU1RBVEUQDxIQCgxJTlRFR0VSX0xJU1QQEBILCgdVTktOT1dOEBISFAoQTEFCRUxfRElDVF9VTkFSWRATEhEKDVNFTEVDVE9SX0xJU1QQFBIbChdMQUJFTF9LRVlFRF9TVFJJTkdfRElDVBAVEiAKHERFUFJFQ0FURURfU1RSSU5HX0RJQ1RfVU5BUlkQESIlCghUcmlzdGF0ZRIGCgJOTxAAEgcKA1lFUxABEggKBEFVVE8QAkoECAwQDUoECBAQESLiAwoEUnVsZRIMCgRuYW1lGAEgAigJEhIKCnJ1bGVfY2xhc3MYAiACKAkSEAoIbG9jYXRpb24YAyABKAkSKQoJYXR0cmlidXRlGAQgAygLMhYuYmxhemVfcXVlcnkuQXR0cmlidXRlEhIKCnJ1bGVfaW5wdXQYBSADKAkSPwoVY29uZmlndXJlZF9ydWxlX2lucHV0GA8gAygLMiAuYmxhemVfcXVlcnkuQ29uZmlndXJlZFJ1bGVJbnB1dBITCgtydWxlX291dHB1dBgGIAMoCRIXCg9kZWZhdWx0X3NldHRpbmcYByADKAkSJAocREVQUkVDQVRFRF9wdWJsaWNfYnlfZGVmYXVsdBgJIAEoCBIdChVERVBSRUNBVEVEX2lzX3NreWxhcmsYCiABKAgSJQodc2t5bGFya19lbnZpcm9ubWVudF9oYXNoX2NvZGUYDCABKAkSGwoTaW5zdGFudGlhdGlvbl9zdGFjaxgNIAMoCRIYChBkZWZpbml0aW9uX3N0YWNrGA4gAygJEhYKDnJ1bGVfY2xhc3Nfa2V5GBAgASgJEjEKD3J1bGVfY2xhc3NfaW5mbxgRIAEoCzIYLnN0YXJkb2Nfb3V0cHV0LlJ1bGVJbmZvSgQICBAJSgQICxAMIl4KE0NvbmZpZ3VyZWRSdWxlSW5wdXQSDQoFbGFiZWwYASABKAkSHgoWY29uZmlndXJhdGlvbl9jaGVja3N1bRgCIAEoCRIYChBjb25maWd1cmF0aW9uX2lkGAMgASgNImcKC1J1bGVTdW1tYXJ5Eh8KBHJ1bGUYASACKAsyES5ibGF6ZV9xdWVyeS5SdWxlEiUKCmRlcGVuZGVuY3kYAiADKAsyES5ibGF6ZV9xdWVyeS5SdWxlEhAKCGxvY2F0aW9uGAMgASgJIl0KDFBhY2thZ2VHcm91cBIMCgRuYW1lGAEgAigJEhkKEWNvbnRhaW5lZF9wYWNrYWdlGAIgAygJEh4KFmluY2x1ZGVkX3BhY2thZ2VfZ3JvdXAYAyADKAlKBAgEEAUiRgoQRW52aXJvbm1lbnRHcm91cBIMCgRuYW1lGAEgAigJEhMKC2Vudmlyb25tZW50GAIgAygJEg8KB2RlZmF1bHQYAyADKAki0AEKClNvdXJjZUZpbGUSDAoEbmFtZRgBIAIoCRIQCghsb2NhdGlvbhgCIAEoCRISCgpzdWJpbmNsdWRlGAMgAygJEhUKDXBhY2thZ2VfZ3JvdXAYBCADKAkSGAoQdmlzaWJpbGl0eV9sYWJlbBgFIAMoCRIPCgdmZWF0dXJlGAYgAygJEiUKB2xpY2Vuc2UYCCABKAsyFC5ibGF6ZV9xdWVyeS5MaWNlbnNlEh8KF3BhY2thZ2VfY29udGFpbnNfZXJyb3JzGAkgASgISgQIBxAIIkgKDUdlbmVyYXRlZEZpbGUSDAoEbmFtZRgBIAIoCRIXCg9nZW5lcmF0aW5nX3J1bGUYAiACKAkSEAoIbG9jYXRpb24YAyABKAkikgMKBlRhcmdldBIvCgR0eXBlGAEgAigOMiEuYmxhemVfcXVlcnkuVGFyZ2V0LkRpc2NyaW1pbmF0b3ISHwoEcnVsZRgCIAEoCzIRLmJsYXplX3F1ZXJ5LlJ1bGUSLAoLc291cmNlX2ZpbGUYAyABKAsyFy5ibGF6ZV9xdWVyeS5Tb3VyY2VGaWxlEjIKDmdlbmVyYXRlZF9maWxlGAQgASgLMhouYmxhemVfcXVlcnkuR2VuZXJhdGVkRmlsZRIwCg1wYWNrYWdlX2dyb3VwGAUgASgLMhkuYmxhemVfcXVlcnkuUGFja2FnZUdyb3VwEjgKEWVudmlyb25tZW50X2dyb3VwGAYgASgLMh0uYmxhemVfcXVlcnkuRW52aXJvbm1lbnRHcm91cCJoCg1EaXNjcmltaW5hdG9yEggKBFJVTEUQARIPCgtTT1VSQ0VfRklMRRACEhIKDkdFTkVSQVRFRF9GSUxFEAMSEQoNUEFDS0FHRV9HUk9VUBAEEhUKEUVOVklST05NRU5UX0dST1VQEAUiMgoLUXVlcnlSZXN1bHQSIwoGdGFyZ2V0GAEgAygLMhMuYmxhemVfcXVlcnkuVGFyZ2V0IqYBChRBbGxvd2VkUnVsZUNsYXNzSW5mbxJECgZwb2xpY3kYASACKA4yNC5ibGF6ZV9xdWVyeS5BbGxvd2VkUnVsZUNsYXNzSW5mby5BbGxvd2VkUnVsZUNsYXNzZXMSGgoSYWxsb3dlZF9ydWxlX2NsYXNzGAIgAygJIiwKEkFsbG93ZWRSdWxlQ2xhc3NlcxIHCgNBTlkQARINCglTUEVDSUZJRUQQAiLuAgoTQXR0cmlidXRlRGVmaW5pdGlvbhIMCgRuYW1lGAEgAigJEjIKBHR5cGUYAiACKA4yJC5ibGF6ZV9xdWVyeS5BdHRyaWJ1dGUuRGlzY3JpbWluYXRvchIRCgltYW5kYXRvcnkYAyABKAgSPwoUYWxsb3dlZF9ydWxlX2NsYXNzZXMYBCABKAsyIS5ibGF6ZV9xdWVyeS5BbGxvd2VkUnVsZUNsYXNzSW5mbxIVCg1kb2N1bWVudGF0aW9uGAUgASgJEhMKC2FsbG93X2VtcHR5GAYgASgIEhkKEWFsbG93X3NpbmdsZV9maWxlGAcgASgIEiwKB2RlZmF1bHQYCSABKAsyGy5ibGF6ZV9xdWVyeS5BdHRyaWJ1dGVWYWx1ZRISCgpleGVjdXRhYmxlGAogASgIEhQKDGNvbmZpZ3VyYWJsZRgLIAEoCBINCgVub2RlcBgMIAEoCBITCgtjZmdfaXNfaG9zdBgNIAEoCCLhAQoOQXR0cmlidXRlVmFsdWUSCwoDaW50GAEgASgFEg4KBnN0cmluZxgCIAEoCRIMCgRib29sGAMgASgIEikKBGxpc3QYBCADKAsyGy5ibGF6ZV9xdWVyeS5BdHRyaWJ1dGVWYWx1ZRIzCgRkaWN0GAUgAygLMiUuYmxhemVfcXVlcnkuQXR0cmlidXRlVmFsdWUuRGljdEVudHJ5GkQKCURpY3RFbnRyeRILCgNrZXkYASACKAkSKgoFdmFsdWUYAiACKAsyGy5ibGF6ZV9xdWVyeS5BdHRyaWJ1dGVWYWx1ZSJ5Cg5SdWxlRGVmaW5pdGlvbhIMCgRuYW1lGAEgAigJEjMKCWF0dHJpYnV0ZRgCIAMoCzIgLmJsYXplX3F1ZXJ5LkF0dHJpYnV0ZURlZmluaXRpb24SFQoNZG9jdW1lbnRhdGlvbhgDIAEoCRINCgVsYWJlbBgEIAEoCSI6Cg1CdWlsZExhbmd1YWdlEikKBHJ1bGUYASADKAsyGy5ibGF6ZV9xdWVyeS5SdWxlRGVmaW5pdGlvbkI2CjRjb20uZ29vZ2xlLmRldnRvb2xzLmJ1aWxkLmxpYi5xdWVyeTIucHJvdG8ucHJvdG8yYXBp", [file_stardoc_output]);

/**
 * @generated from message blaze_query.License
 */
export type License = Message<"blaze_query.License"> & {
  /**
   * @generated from field: repeated string license_type = 1;
   */
  licenseType: string[];

  /**
   * @generated from field: repeated string exception = 2;
   */
  exception: string[];
};

/**
 * Describes the message blaze_query.License.
 * Use `create(LicenseSchema)` to create a new message.
 */
export const LicenseSchema: GenMessage<License> = /*@__PURE__*/
  messageDesc(file_build, 0);

/**
 * @generated from message blaze_query.StringDictEntry
 */
export type StringDictEntry = Message<"blaze_query.StringDictEntry"> & {
  /**
   * @generated from field: required string key = 1;
   */
  key: string;

  /**
   * @generated from field: required string value = 2;
   */
  value: string;
};

/**
 * Describes the message blaze_query.StringDictEntry.
 * Use `create(StringDictEntrySchema)` to create a new message.
 */
export const StringDictEntrySchema: GenMessage<StringDictEntry> = /*@__PURE__*/
  messageDesc(file_build, 1);

/**
 * @generated from message blaze_query.LabelDictUnaryEntry
 */
export type LabelDictUnaryEntry = Message<"blaze_query.LabelDictUnaryEntry"> & {
  /**
   * @generated from field: required string key = 1;
   */
  key: string;

  /**
   * @generated from field: required string value = 2;
   */
  value: string;
};

/**
 * Describes the message blaze_query.LabelDictUnaryEntry.
 * Use `create(LabelDictUnaryEntrySchema)` to create a new message.
 */
export const LabelDictUnaryEntrySchema: GenMessage<LabelDictUnaryEntry> = /*@__PURE__*/
  messageDesc(file_build, 2);

/**
 * @generated from message blaze_query.LabelListDictEntry
 */
export type LabelListDictEntry = Message<"blaze_query.LabelListDictEntry"> & {
  /**
   * @generated from field: required string key = 1;
   */
  key: string;

  /**
   * @generated from field: repeated string value = 2;
   */
  value: string[];
};

/**
 * Describes the message blaze_query.LabelListDictEntry.
 * Use `create(LabelListDictEntrySchema)` to create a new message.
 */
export const LabelListDictEntrySchema: GenMessage<LabelListDictEntry> = /*@__PURE__*/
  messageDesc(file_build, 3);

/**
 * @generated from message blaze_query.LabelKeyedStringDictEntry
 */
export type LabelKeyedStringDictEntry = Message<"blaze_query.LabelKeyedStringDictEntry"> & {
  /**
   * @generated from field: required string key = 1;
   */
  key: string;

  /**
   * @generated from field: required string value = 2;
   */
  value: string;
};

/**
 * Describes the message blaze_query.LabelKeyedStringDictEntry.
 * Use `create(LabelKeyedStringDictEntrySchema)` to create a new message.
 */
export const LabelKeyedStringDictEntrySchema: GenMessage<LabelKeyedStringDictEntry> = /*@__PURE__*/
  messageDesc(file_build, 4);

/**
 * @generated from message blaze_query.StringListDictEntry
 */
export type StringListDictEntry = Message<"blaze_query.StringListDictEntry"> & {
  /**
   * @generated from field: required string key = 1;
   */
  key: string;

  /**
   * @generated from field: repeated string value = 2;
   */
  value: string[];
};

/**
 * Describes the message blaze_query.StringListDictEntry.
 * Use `create(StringListDictEntrySchema)` to create a new message.
 */
export const StringListDictEntrySchema: GenMessage<StringListDictEntry> = /*@__PURE__*/
  messageDesc(file_build, 5);

/**
 * Represents an entry attribute of a Fileset rule in a build file.
 *
 * @generated from message blaze_query.FilesetEntry
 */
export type FilesetEntry = Message<"blaze_query.FilesetEntry"> & {
  /**
   * The label pointing to the source target where files are copied from.
   *
   * @generated from field: required string source = 1;
   */
  source: string;

  /**
   * The relative path within the fileset rule where files will be mapped.
   *
   * @generated from field: required string destination_directory = 2;
   */
  destinationDirectory: string;

  /**
   * Whether the files= attribute was specified. This is necessary because
   * no files= attribute and files=[] mean different things.
   *
   * @generated from field: optional bool files_present = 7;
   */
  filesPresent: boolean;

  /**
   * A list of file labels to include from the source directory.
   *
   * @generated from field: repeated string file = 3;
   */
  file: string[];

  /**
   * If this is a fileset entry representing files within the rule
   * package, this lists relative paths to files that should be excluded from
   * the set.  This cannot contain values if 'file' also has values.
   *
   * @generated from field: repeated string exclude = 4;
   */
  exclude: string[];

  /**
   * This field is optional because there will be some time when the new
   * PB is used by tools depending on blaze query, but the new blaze version
   * is not yet released.
   * TODO(bazel-team): Make this field required once a version of Blaze is
   * released that outputs this field.
   *
   * @generated from field: optional blaze_query.FilesetEntry.SymlinkBehavior symlink_behavior = 5 [default = COPY];
   */
  symlinkBehavior: FilesetEntry_SymlinkBehavior;

  /**
   * The prefix to strip from the path of the files in this FilesetEntry. Note
   * that no value and the empty string as the value mean different things here.
   *
   * @generated from field: optional string strip_prefix = 6;
   */
  stripPrefix: string;
};

/**
 * Describes the message blaze_query.FilesetEntry.
 * Use `create(FilesetEntrySchema)` to create a new message.
 */
export const FilesetEntrySchema: GenMessage<FilesetEntry> = /*@__PURE__*/
  messageDesc(file_build, 6);

/**
 * Indicates what to do when a source file is actually a symlink.
 *
 * @generated from enum blaze_query.FilesetEntry.SymlinkBehavior
 */
export enum FilesetEntry_SymlinkBehavior {
  /**
   * @generated from enum value: COPY = 1;
   */
  COPY = 1,

  /**
   * @generated from enum value: DEREFERENCE = 2;
   */
  DEREFERENCE = 2,
}

/**
 * Describes the enum blaze_query.FilesetEntry.SymlinkBehavior.
 */
export const FilesetEntry_SymlinkBehaviorSchema: GenEnum<FilesetEntry_SymlinkBehavior> = /*@__PURE__*/
  enumDesc(file_build, 6, 0);

/**
 * A rule attribute. Each attribute must have a type and one of the various
 * value fields populated - for the most part.
 *
 * Attributes of BOOLEAN and TRISTATE type may set all of the int, bool, and
 * string values for backwards compatibility with clients that expect them to
 * be set.
 *
 * Attributes of INTEGER, STRING, LABEL, LICENSE, BOOLEAN, and TRISTATE type
 * may set *none* of the values. This can happen if the Attribute message is
 * prepared for a client that doesn't support SELECTOR_LIST, but the rule has
 * a selector list value for the attribute. (Selector lists for attributes of
 * other types--the collection types--are handled differently when prepared
 * for such a client. The possible collection values are gathered together
 * and flattened.)
 *
 * By checking the type, the appropriate value can be extracted - see the
 * comments on each type for the associated value.  The order of lists comes
 * from the blaze parsing. If an attribute is of a list type, the associated
 * list should never be empty.
 *
 * @generated from message blaze_query.Attribute
 */
export type Attribute = Message<"blaze_query.Attribute"> & {
  /**
   * The name of the attribute
   *
   * @generated from field: required string name = 1;
   */
  name: string;

  /**
   * Whether the attribute was explicitly specified
   *
   * @generated from field: optional bool explicitly_specified = 13;
   */
  explicitlySpecified: boolean;

  /**
   * If this attribute has a string value or a string list value, then this
   * may be set to indicate that the value may be treated as a label that
   * isn't a dependency of this attribute's rule.
   *
   * @generated from field: optional bool nodep = 20;
   */
  nodep: boolean;

  /**
   * Represents the aspect that this attribute comes from. It is set to an
   * empty string if it does not come from an aspect.
   *
   * @generated from field: optional string source_aspect_name = 23;
   */
  sourceAspectName: string;

  /**
   * The type of attribute.  This message is used for all of the different
   * attribute types so the discriminator helps for figuring out what is
   * stored in the message.
   *
   * @generated from field: required blaze_query.Attribute.Discriminator type = 2;
   */
  type: Attribute_Discriminator;

  /**
   * If this attribute has an integer value this will be populated.
   * Boolean and TriState also use this field as [0,1] and [-1,0,1]
   * for [false, true] and [auto, no, yes] respectively.
   *
   * @generated from field: optional int32 int_value = 3;
   */
  intValue: number;

  /**
   * If the attribute has a string value this will be populated.  Label and
   * path attributes use this field as the value even though the type may
   * be LABEL or something else other than STRING.
   *
   * @generated from field: optional string string_value = 5;
   */
  stringValue: string;

  /**
   * If the attribute has a boolean value this will be populated.
   *
   * @generated from field: optional bool boolean_value = 14;
   */
  booleanValue: boolean;

  /**
   * If the attribute is a Tristate value, this will be populated.
   *
   * @generated from field: optional blaze_query.Attribute.Tristate tristate_value = 15;
   */
  tristateValue: Attribute_Tristate;

  /**
   * The value of the attribute has a list of string values (label and path
   * note from STRING applies here as well).
   *
   * @generated from field: repeated string string_list_value = 6;
   */
  stringListValue: string[];

  /**
   * If this is a license attribute, the license information is stored here.
   *
   * @generated from field: optional blaze_query.License license = 7;
   */
  license?: License;

  /**
   * If this is a string dict, each entry will be stored here.
   *
   * @generated from field: repeated blaze_query.StringDictEntry string_dict_value = 8;
   */
  stringDictValue: StringDictEntry[];

  /**
   * If the attribute is part of a Fileset, the fileset entries are stored in
   * this field.
   *
   * @generated from field: repeated blaze_query.FilesetEntry fileset_list_value = 9;
   */
  filesetListValue: FilesetEntry[];

  /**
   * If this is a label list dict, each entry will be stored here.
   *
   * @generated from field: repeated blaze_query.LabelListDictEntry label_list_dict_value = 10;
   */
  labelListDictValue: LabelListDictEntry[];

  /**
   * If this is a string list dict, each entry will be stored here.
   *
   * @generated from field: repeated blaze_query.StringListDictEntry string_list_dict_value = 11;
   */
  stringListDictValue: StringListDictEntry[];

  /**
   * The value of the attribute has a list of int32 values
   *
   * @generated from field: repeated int32 int_list_value = 17;
   */
  intListValue: number[];

  /**
   * If this is a label dict unary, each entry will be stored here.
   *
   * @generated from field: repeated blaze_query.LabelDictUnaryEntry label_dict_unary_value = 19;
   */
  labelDictUnaryValue: LabelDictUnaryEntry[];

  /**
   * If this is a label-keyed string dict, each entry will be stored here.
   *
   * @generated from field: repeated blaze_query.LabelKeyedStringDictEntry label_keyed_string_dict_value = 22;
   */
  labelKeyedStringDictValue: LabelKeyedStringDictEntry[];

  /**
   * If this attribute's value is an expression containing one or more select
   * expressions, then its type is SELECTOR_LIST and a SelectorList will be
   * stored here.
   *
   * @generated from field: optional blaze_query.Attribute.SelectorList selector_list = 21;
   */
  selectorList?: Attribute_SelectorList;

  /**
   * @generated from field: repeated bytes DEPRECATED_string_dict_unary_value = 18;
   */
  DEPRECATEDStringDictUnaryValue: Uint8Array[];
};

/**
 * Describes the message blaze_query.Attribute.
 * Use `create(AttributeSchema)` to create a new message.
 */
export const AttributeSchema: GenMessage<Attribute> = /*@__PURE__*/
  messageDesc(file_build, 7);

/**
 * @generated from message blaze_query.Attribute.SelectorEntry
 */
export type Attribute_SelectorEntry = Message<"blaze_query.Attribute.SelectorEntry"> & {
  /**
   * The key of the selector entry. At this time, this is the label of a
   * config_setting rule, or the pseudo-label "//conditions:default".
   *
   * @generated from field: optional string label = 1;
   */
  label: string;

  /**
   * True if the entry's value is the default value for the type as a
   * result of the condition value being specified as None (ie:
   * {"//condition": None}).
   *
   * @generated from field: optional bool is_default_value = 16;
   */
  isDefaultValue: boolean;

  /**
   * Exactly one of the following fields (except for glob_criteria) must be
   * populated - note that the BOOLEAN and TRISTATE caveat in Attribute's
   * comment does not apply here. The type field in the SelectorList
   * containing this entry indicates which of these fields is populated,
   * in accordance with the comments on Discriminator enum values above.
   * (To be explicit: BOOLEAN populates the boolean_value field and TRISTATE
   * populates the tristate_value field.)
   *
   * @generated from field: optional int32 int_value = 2;
   */
  intValue: number;

  /**
   * @generated from field: optional string string_value = 3;
   */
  stringValue: string;

  /**
   * @generated from field: optional bool boolean_value = 4;
   */
  booleanValue: boolean;

  /**
   * @generated from field: optional blaze_query.Attribute.Tristate tristate_value = 5;
   */
  tristateValue: Attribute_Tristate;

  /**
   * @generated from field: repeated string string_list_value = 6;
   */
  stringListValue: string[];

  /**
   * @generated from field: optional blaze_query.License license = 7;
   */
  license?: License;

  /**
   * @generated from field: repeated blaze_query.StringDictEntry string_dict_value = 8;
   */
  stringDictValue: StringDictEntry[];

  /**
   * @generated from field: repeated blaze_query.FilesetEntry fileset_list_value = 9;
   */
  filesetListValue: FilesetEntry[];

  /**
   * @generated from field: repeated blaze_query.LabelListDictEntry label_list_dict_value = 10;
   */
  labelListDictValue: LabelListDictEntry[];

  /**
   * @generated from field: repeated blaze_query.StringListDictEntry string_list_dict_value = 11;
   */
  stringListDictValue: StringListDictEntry[];

  /**
   * @generated from field: repeated int32 int_list_value = 13;
   */
  intListValue: number[];

  /**
   * @generated from field: repeated blaze_query.LabelDictUnaryEntry label_dict_unary_value = 15;
   */
  labelDictUnaryValue: LabelDictUnaryEntry[];

  /**
   * @generated from field: repeated blaze_query.LabelKeyedStringDictEntry label_keyed_string_dict_value = 17;
   */
  labelKeyedStringDictValue: LabelKeyedStringDictEntry[];

  /**
   * @generated from field: repeated bytes DEPRECATED_string_dict_unary_value = 14;
   */
  DEPRECATEDStringDictUnaryValue: Uint8Array[];
};

/**
 * Describes the message blaze_query.Attribute.SelectorEntry.
 * Use `create(Attribute_SelectorEntrySchema)` to create a new message.
 */
export const Attribute_SelectorEntrySchema: GenMessage<Attribute_SelectorEntry> = /*@__PURE__*/
  messageDesc(file_build, 7, 0);

/**
 * @generated from message blaze_query.Attribute.Selector
 */
export type Attribute_Selector = Message<"blaze_query.Attribute.Selector"> & {
  /**
   * The list of (label, value) pairs in the map that defines the selector.
   * At this time, this cannot be empty, i.e. a selector has at least one
   * entry.
   *
   * @generated from field: repeated blaze_query.Attribute.SelectorEntry entries = 1;
   */
  entries: Attribute_SelectorEntry[];

  /**
   * Whether or not this has any default values.
   *
   * @generated from field: optional bool has_default_value = 2;
   */
  hasDefaultValue: boolean;

  /**
   * The error message when no condition matches.
   *
   * @generated from field: optional string no_match_error = 3;
   */
  noMatchError: string;
};

/**
 * Describes the message blaze_query.Attribute.Selector.
 * Use `create(Attribute_SelectorSchema)` to create a new message.
 */
export const Attribute_SelectorSchema: GenMessage<Attribute_Selector> = /*@__PURE__*/
  messageDesc(file_build, 7, 1);

/**
 * @generated from message blaze_query.Attribute.SelectorList
 */
export type Attribute_SelectorList = Message<"blaze_query.Attribute.SelectorList"> & {
  /**
   * The type that this selector list evaluates to, and the type that each
   * selector in the list evaluates to. At this time, this cannot be
   * SELECTOR_LIST, i.e. selector lists do not nest.
   *
   * @generated from field: optional blaze_query.Attribute.Discriminator type = 1;
   */
  type: Attribute_Discriminator;

  /**
   * The list of selector elements in this selector list. At this time, this
   * cannot be empty, i.e. a selector list is never empty.
   *
   * @generated from field: repeated blaze_query.Attribute.Selector elements = 2;
   */
  elements: Attribute_Selector[];
};

/**
 * Describes the message blaze_query.Attribute.SelectorList.
 * Use `create(Attribute_SelectorListSchema)` to create a new message.
 */
export const Attribute_SelectorListSchema: GenMessage<Attribute_SelectorList> = /*@__PURE__*/
  messageDesc(file_build, 7, 2);

/**
 * Indicates the type of attribute.
 *
 * @generated from enum blaze_query.Attribute.Discriminator
 */
export enum Attribute_Discriminator {
  /**
   * int_value
   *
   * @generated from enum value: INTEGER = 1;
   */
  INTEGER = 1,

  /**
   * string_value
   *
   * @generated from enum value: STRING = 2;
   */
  STRING = 2,

  /**
   * string_value
   *
   * @generated from enum value: LABEL = 3;
   */
  LABEL = 3,

  /**
   * string_value
   *
   * @generated from enum value: OUTPUT = 4;
   */
  OUTPUT = 4,

  /**
   * string_list_value
   *
   * @generated from enum value: STRING_LIST = 5;
   */
  STRING_LIST = 5,

  /**
   * string_list_value
   *
   * @generated from enum value: LABEL_LIST = 6;
   */
  LABEL_LIST = 6,

  /**
   * string_list_value
   *
   * @generated from enum value: OUTPUT_LIST = 7;
   */
  OUTPUT_LIST = 7,

  /**
   * string_list_value - order is unimportant
   *
   * @generated from enum value: DISTRIBUTION_SET = 8;
   */
  DISTRIBUTION_SET = 8,

  /**
   * license
   *
   * @generated from enum value: LICENSE = 9;
   */
  LICENSE = 9,

  /**
   * string_dict_value
   *
   * @generated from enum value: STRING_DICT = 10;
   */
  STRING_DICT = 10,

  /**
   * fileset_list_value
   *
   * @generated from enum value: FILESET_ENTRY_LIST = 11;
   */
  FILESET_ENTRY_LIST = 11,

  /**
   * label_list_dict_value
   *
   * @generated from enum value: LABEL_LIST_DICT = 12;
   */
  LABEL_LIST_DICT = 12,

  /**
   * string_list_dict_value
   *
   * @generated from enum value: STRING_LIST_DICT = 13;
   */
  STRING_LIST_DICT = 13,

  /**
   * int, bool and string value
   *
   * @generated from enum value: BOOLEAN = 14;
   */
  BOOLEAN = 14,

  /**
   * tristate, int and string value
   *
   * @generated from enum value: TRISTATE = 15;
   */
  TRISTATE = 15,

  /**
   * int_list_value
   *
   * @generated from enum value: INTEGER_LIST = 16;
   */
  INTEGER_LIST = 16,

  /**
   * unknown type, use only for build extensions
   *
   * @generated from enum value: UNKNOWN = 18;
   */
  UNKNOWN = 18,

  /**
   * label_dict_unary_value
   *
   * @generated from enum value: LABEL_DICT_UNARY = 19;
   */
  LABEL_DICT_UNARY = 19,

  /**
   * selector_list
   *
   * @generated from enum value: SELECTOR_LIST = 20;
   */
  SELECTOR_LIST = 20,

  /**
   * label_keyed_string_dict
   *
   * @generated from enum value: LABEL_KEYED_STRING_DICT = 21;
   */
  LABEL_KEYED_STRING_DICT = 21,

  /**
   * @generated from enum value: DEPRECATED_STRING_DICT_UNARY = 17;
   */
  DEPRECATED_STRING_DICT_UNARY = 17,
}

/**
 * Describes the enum blaze_query.Attribute.Discriminator.
 */
export const Attribute_DiscriminatorSchema: GenEnum<Attribute_Discriminator> = /*@__PURE__*/
  enumDesc(file_build, 7, 0);

/**
 * Values for the TriState field type.
 *
 * @generated from enum blaze_query.Attribute.Tristate
 */
export enum Attribute_Tristate {
  /**
   * @generated from enum value: NO = 0;
   */
  NO = 0,

  /**
   * @generated from enum value: YES = 1;
   */
  YES = 1,

  /**
   * @generated from enum value: AUTO = 2;
   */
  AUTO = 2,
}

/**
 * Describes the enum blaze_query.Attribute.Tristate.
 */
export const Attribute_TristateSchema: GenEnum<Attribute_Tristate> = /*@__PURE__*/
  enumDesc(file_build, 7, 1);

/**
 * A rule instance (e.g., cc_library foo, java_binary bar).
 *
 * @generated from message blaze_query.Rule
 */
export type Rule = Message<"blaze_query.Rule"> & {
  /**
   * The name of the rule (formatted as an absolute label, e.g. //foo/bar:baz).
   *
   * @generated from field: required string name = 1;
   */
  name: string;

  /**
   * The rule class name (e.g., java_library).
   *
   * Note that the rule class name may not uniquely identify a rule class, since
   * two different .bzl files may define different rule classes with the same
   * name. To uniquely identify the rule class, see rule_class_key field below.
   *
   * @generated from field: required string rule_class = 2;
   */
  ruleClass: string;

  /**
   * The BUILD file and line number of the location (formatted as
   * <absolute_path>:<line_number>:<column_number>) in the rule's package's
   * BUILD file where the rule instance was instantiated. The line number will
   * be that of a rule invocation or macro call (that in turn invoked a
   * rule). See
   * https://bazel.build/rules/macros#macro-creation
   *
   * @generated from field: optional string location = 3;
   */
  location: string;

  /**
   * All of the attributes that describe the rule.
   *
   * @generated from field: repeated blaze_query.Attribute attribute = 4;
   */
  attribute: Attribute[];

  /**
   * All of the inputs to the rule (formatted as absolute labels). These are
   * predecessors in the dependency graph.
   *
   * @generated from field: repeated string rule_input = 5;
   */
  ruleInput: string[];

  /**
   * @generated from field: repeated blaze_query.ConfiguredRuleInput configured_rule_input = 15;
   */
  configuredRuleInput: ConfiguredRuleInput[];

  /**
   * All of the outputs of the rule (formatted as absolute labels). These are
   * successors in the dependency graph.
   *
   * @generated from field: repeated string rule_output = 6;
   */
  ruleOutput: string[];

  /**
   * The set of all "features" inherited from the rule's package declaration.
   *
   * @generated from field: repeated string default_setting = 7;
   */
  defaultSetting: string[];

  /**
   * The rule's class's public by default value.
   *
   * @generated from field: optional bool DEPRECATED_public_by_default = 9;
   */
  DEPRECATEDPublicByDefault: boolean;

  /**
   * @generated from field: optional bool DEPRECATED_is_skylark = 10;
   */
  DEPRECATEDIsSkylark: boolean;

  /**
   * Hash encapsulating the behavior of this Starlark rule. Any change to this
   * rule's definition that could change its behavior will be reflected here.
   *
   * @generated from field: optional string skylark_environment_hash_code = 12;
   */
  skylarkEnvironmentHashCode: string;

  /**
   * The Starlark call stack at the moment the rule was instantiated.
   * Each entry has the form "file:line:col: function".
   * The outermost stack frame ("<toplevel>", the BUILD file) appears first;
   * the frame for the rule function itself is omitted.
   * The file name may be relative to package's source root directory.
   *
   * Requires --proto:instantiation_stack=true.
   *
   * @generated from field: repeated string instantiation_stack = 13;
   */
  instantiationStack: string[];

  /**
   * The Starlark call stack for the definition of the rule class of this
   * particular rule instance. If empty, either populating the field was not
   * enabled on the command line with the --proto:definition_stack flag or the
   * rule is a native one.
   *
   * @generated from field: repeated string definition_stack = 14;
   */
  definitionStack: string[];

  /**
   * A key uniquely identifying the rule's rule class. Stable between repeated
   * blaze query invocations (assuming that there are no changes to Starlark
   * files and the same blaze binary is invoked with the same options).
   *
   * Requires --proto:rule_classes=true
   *
   * @generated from field: optional string rule_class_key = 16;
   */
  ruleClassKey: string;

  /**
   * Stardoc-format rule class API definition for this rule. Includes both
   * Starlark-defined and native (including inherited) attributes; does not
   * include hidden or explicitly undocumented attributes.
   *
   * Populated only for the first rule in the stream with a given
   * rule_class_key.
   *
   * Requires --proto:rule_classes=true
   *
   * @generated from field: optional stardoc_output.RuleInfo rule_class_info = 17;
   */
  ruleClassInfo?: RuleInfo;
};

/**
 * Describes the message blaze_query.Rule.
 * Use `create(RuleSchema)` to create a new message.
 */
export const RuleSchema: GenMessage<Rule> = /*@__PURE__*/
  messageDesc(file_build, 8);

/**
 * Direct dependencies of a rule in <depLabel, depConfiguration> form.
 *
 * @generated from message blaze_query.ConfiguredRuleInput
 */
export type ConfiguredRuleInput = Message<"blaze_query.ConfiguredRuleInput"> & {
  /**
   * Dep's target label.
   *
   * @generated from field: optional string label = 1;
   */
  label: string;

  /**
   * Dep's configuration if the dep isn't a source file, else unset.
   *
   * @generated from field: optional string configuration_checksum = 2;
   */
  configurationChecksum: string;

  /**
   * Reference to this dep's configuration if --proto:include_configurations is
   * set: see
   * https://github.com/bazelbuild/bazel/blob/7278be3f9b0c26842ecb8225f0215c1e4aede5a9/src/main/protobuf/analysis_v2.proto#L189.
   * If this dep is a source file, this is unset.
   *
   * @generated from field: optional uint32 configuration_id = 3;
   */
  configurationId: number;
};

/**
 * Describes the message blaze_query.ConfiguredRuleInput.
 * Use `create(ConfiguredRuleInputSchema)` to create a new message.
 */
export const ConfiguredRuleInputSchema: GenMessage<ConfiguredRuleInput> = /*@__PURE__*/
  messageDesc(file_build, 9);

/**
 * Summary of all transitive dependencies of 'rule,' where each dependent
 * rule is included only once in the 'dependency' field.  Gives complete
 * information to analyze the single build target labeled rule.name,
 * including optional location of target in BUILD file.
 *
 * @generated from message blaze_query.RuleSummary
 */
export type RuleSummary = Message<"blaze_query.RuleSummary"> & {
  /**
   * @generated from field: required blaze_query.Rule rule = 1;
   */
  rule?: Rule;

  /**
   * @generated from field: repeated blaze_query.Rule dependency = 2;
   */
  dependency: Rule[];

  /**
   * @generated from field: optional string location = 3;
   */
  location: string;
};

/**
 * Describes the message blaze_query.RuleSummary.
 * Use `create(RuleSummarySchema)` to create a new message.
 */
export const RuleSummarySchema: GenMessage<RuleSummary> = /*@__PURE__*/
  messageDesc(file_build, 10);

/**
 * A package group. Aside from the name, it contains the list of packages
 * present in the group (as specified in the BUILD file).
 *
 * @generated from message blaze_query.PackageGroup
 */
export type PackageGroup = Message<"blaze_query.PackageGroup"> & {
  /**
   * The name of the package group
   *
   * @generated from field: required string name = 1;
   */
  name: string;

  /**
   * The list of packages as specified in the BUILD file. Currently this is
   * only a list of packages, but some time in the future, there might be
   * some type of wildcard mechanism.
   *
   * @generated from field: repeated string contained_package = 2;
   */
  containedPackage: string[];

  /**
   * The list of sub package groups included in this one.
   *
   * @generated from field: repeated string included_package_group = 3;
   */
  includedPackageGroup: string[];
};

/**
 * Describes the message blaze_query.PackageGroup.
 * Use `create(PackageGroupSchema)` to create a new message.
 */
export const PackageGroupSchema: GenMessage<PackageGroup> = /*@__PURE__*/
  messageDesc(file_build, 11);

/**
 * An environment group.
 *
 * @generated from message blaze_query.EnvironmentGroup
 */
export type EnvironmentGroup = Message<"blaze_query.EnvironmentGroup"> & {
  /**
   * The name of the environment group.
   *
   * @generated from field: required string name = 1;
   */
  name: string;

  /**
   * The environments that belong to this group (as labels).
   *
   * @generated from field: repeated string environment = 2;
   */
  environment: string[];

  /**
   * The member environments that rules implicitly support if not otherwise
   * specified.
   *
   * @generated from field: repeated string default = 3;
   */
  default: string[];
};

/**
 * Describes the message blaze_query.EnvironmentGroup.
 * Use `create(EnvironmentGroupSchema)` to create a new message.
 */
export const EnvironmentGroupSchema: GenMessage<EnvironmentGroup> = /*@__PURE__*/
  messageDesc(file_build, 12);

/**
 * A file that is an input into the build system.
 * Next-Id: 10
 *
 * @generated from message blaze_query.SourceFile
 */
export type SourceFile = Message<"blaze_query.SourceFile"> & {
  /**
   * The name of the source file (a label).
   *
   * @generated from field: required string name = 1;
   */
  name: string;

  /**
   * The location of the source file.  This is a path with a line number and a
   * column number not a label in the build system.
   *
   * @generated from field: optional string location = 2;
   */
  location: string;

  /**
   * Labels of .bzl (Starlark) files that are transitively loaded in this BUILD
   * file. This is present only when the SourceFile represents a BUILD file that
   * loaded .bzl files.
   * TODO(bazel-team): Rename this field.
   *
   * @generated from field: repeated string subinclude = 3;
   */
  subinclude: string[];

  /**
   * Labels of package groups that are mentioned in the visibility declaration
   * for this source file.
   *
   * @generated from field: repeated string package_group = 4;
   */
  packageGroup: string[];

  /**
   * Labels mentioned in the visibility declaration (including :__pkg__ and
   * //visibility: ones)
   *
   * @generated from field: repeated string visibility_label = 5;
   */
  visibilityLabel: string[];

  /**
   * The package-level features enabled for this package. Only present if the
   * SourceFile represents a BUILD file.
   *
   * @generated from field: repeated string feature = 6;
   */
  feature: string[];

  /**
   * License attribute for the file.
   *
   * @generated from field: optional blaze_query.License license = 8;
   */
  license?: License;

  /**
   * True if the package contains an error. Only present if the SourceFile
   * represents a BUILD file.
   *
   * @generated from field: optional bool package_contains_errors = 9;
   */
  packageContainsErrors: boolean;
};

/**
 * Describes the message blaze_query.SourceFile.
 * Use `create(SourceFileSchema)` to create a new message.
 */
export const SourceFileSchema: GenMessage<SourceFile> = /*@__PURE__*/
  messageDesc(file_build, 13);

/**
 * A file that is the output of a build rule.
 *
 * @generated from message blaze_query.GeneratedFile
 */
export type GeneratedFile = Message<"blaze_query.GeneratedFile"> & {
  /**
   * The name of the generated file (a label).
   *
   * @generated from field: required string name = 1;
   */
  name: string;

  /**
   * The label of the target that generates the file.
   *
   * @generated from field: required string generating_rule = 2;
   */
  generatingRule: string;

  /**
   * The path, line number, and column number of the output file (not a label).
   *
   * @generated from field: optional string location = 3;
   */
  location: string;
};

/**
 * Describes the message blaze_query.GeneratedFile.
 * Use `create(GeneratedFileSchema)` to create a new message.
 */
export const GeneratedFileSchema: GenMessage<GeneratedFile> = /*@__PURE__*/
  messageDesc(file_build, 14);

/**
 * A target from a blaze query execution.  Similar to the Attribute message,
 * the Discriminator is used to determine which field contains information.
 * For any given type, only one of these can be populated in a single Target.
 *
 * @generated from message blaze_query.Target
 */
export type Target = Message<"blaze_query.Target"> & {
  /**
   * The type of target contained in the message.
   *
   * @generated from field: required blaze_query.Target.Discriminator type = 1;
   */
  type: Target_Discriminator;

  /**
   * If this target represents a rule, the rule is stored here.
   *
   * @generated from field: optional blaze_query.Rule rule = 2;
   */
  rule?: Rule;

  /**
   * A file that is not generated by the build system (version controlled
   * or created by the test harness).
   *
   * @generated from field: optional blaze_query.SourceFile source_file = 3;
   */
  sourceFile?: SourceFile;

  /**
   * A generated file that is the output of a rule.
   *
   * @generated from field: optional blaze_query.GeneratedFile generated_file = 4;
   */
  generatedFile?: GeneratedFile;

  /**
   * A package group.
   *
   * @generated from field: optional blaze_query.PackageGroup package_group = 5;
   */
  packageGroup?: PackageGroup;

  /**
   * An environment group.
   *
   * @generated from field: optional blaze_query.EnvironmentGroup environment_group = 6;
   */
  environmentGroup?: EnvironmentGroup;
};

/**
 * Describes the message blaze_query.Target.
 * Use `create(TargetSchema)` to create a new message.
 */
export const TargetSchema: GenMessage<Target> = /*@__PURE__*/
  messageDesc(file_build, 15);

/**
 * @generated from enum blaze_query.Target.Discriminator
 */
export enum Target_Discriminator {
  /**
   * @generated from enum value: RULE = 1;
   */
  RULE = 1,

  /**
   * @generated from enum value: SOURCE_FILE = 2;
   */
  SOURCE_FILE = 2,

  /**
   * @generated from enum value: GENERATED_FILE = 3;
   */
  GENERATED_FILE = 3,

  /**
   * @generated from enum value: PACKAGE_GROUP = 4;
   */
  PACKAGE_GROUP = 4,

  /**
   * @generated from enum value: ENVIRONMENT_GROUP = 5;
   */
  ENVIRONMENT_GROUP = 5,
}

/**
 * Describes the enum blaze_query.Target.Discriminator.
 */
export const Target_DiscriminatorSchema: GenEnum<Target_Discriminator> = /*@__PURE__*/
  enumDesc(file_build, 15, 0);

/**
 * Container for all of the blaze query results.
 *
 * @generated from message blaze_query.QueryResult
 */
export type QueryResult = Message<"blaze_query.QueryResult"> & {
  /**
   * All of the targets returned by the blaze query.
   *
   * @generated from field: repeated blaze_query.Target target = 1;
   */
  target: Target[];
};

/**
 * Describes the message blaze_query.QueryResult.
 * Use `create(QueryResultSchema)` to create a new message.
 */
export const QueryResultSchema: GenMessage<QueryResult> = /*@__PURE__*/
  messageDesc(file_build, 16);

/**
 * Information about allowed rule classes for a specific attribute of a rule.
 *
 * @generated from message blaze_query.AllowedRuleClassInfo
 */
export type AllowedRuleClassInfo = Message<"blaze_query.AllowedRuleClassInfo"> & {
  /**
   * @generated from field: required blaze_query.AllowedRuleClassInfo.AllowedRuleClasses policy = 1;
   */
  policy: AllowedRuleClassInfo_AllowedRuleClasses;

  /**
   * Rule class names of rules allowed in this attribute, e.g "cc_library",
   * "py_binary". Only present if the allowed_rule_classes field is set to
   * SPECIFIED.
   *
   * @generated from field: repeated string allowed_rule_class = 2;
   */
  allowedRuleClass: string[];
};

/**
 * Describes the message blaze_query.AllowedRuleClassInfo.
 * Use `create(AllowedRuleClassInfoSchema)` to create a new message.
 */
export const AllowedRuleClassInfoSchema: GenMessage<AllowedRuleClassInfo> = /*@__PURE__*/
  messageDesc(file_build, 17);

/**
 * @generated from enum blaze_query.AllowedRuleClassInfo.AllowedRuleClasses
 */
export enum AllowedRuleClassInfo_AllowedRuleClasses {
  /**
   * Any rule is allowed to be in this attribute
   *
   * @generated from enum value: ANY = 1;
   */
  ANY = 1,

  /**
   * Only the explicitly listed rules are allowed
   *
   * @generated from enum value: SPECIFIED = 2;
   */
  SPECIFIED = 2,
}

/**
 * Describes the enum blaze_query.AllowedRuleClassInfo.AllowedRuleClasses.
 */
export const AllowedRuleClassInfo_AllowedRuleClassesSchema: GenEnum<AllowedRuleClassInfo_AllowedRuleClasses> = /*@__PURE__*/
  enumDesc(file_build, 17, 0);

/**
 * This message represents a single attribute of a single rule.
 * See https://bazel.build/rules/lib/attr.
 *
 * @generated from message blaze_query.AttributeDefinition
 */
export type AttributeDefinition = Message<"blaze_query.AttributeDefinition"> & {
  /**
   * e.g. "name", "srcs"
   *
   * @generated from field: required string name = 1;
   */
  name: string;

  /**
   * @generated from field: required blaze_query.Attribute.Discriminator type = 2;
   */
  type: Attribute_Discriminator;

  /**
   * @generated from field: optional bool mandatory = 3;
   */
  mandatory: boolean;

  /**
   * type=label*
   *
   * @generated from field: optional blaze_query.AllowedRuleClassInfo allowed_rule_classes = 4;
   */
  allowedRuleClasses?: AllowedRuleClassInfo;

  /**
   * @generated from field: optional string documentation = 5;
   */
  documentation: string;

  /**
   * type=*_list|*_dict
   *
   * @generated from field: optional bool allow_empty = 6;
   */
  allowEmpty: boolean;

  /**
   * type=label
   *
   * @generated from field: optional bool allow_single_file = 7;
   */
  allowSingleFile: boolean;

  /**
   * simple (not computed/late-bound) values only
   *
   * @generated from field: optional blaze_query.AttributeValue default = 9;
   */
  default?: AttributeValue;

  /**
   * type=label
   *
   * @generated from field: optional bool executable = 10;
   */
  executable: boolean;

  /**
   * @generated from field: optional bool configurable = 11;
   */
  configurable: boolean;

  /**
   * label-valued edge does not establish a dependency
   *
   * @generated from field: optional bool nodep = 12;
   */
  nodep: boolean;

  /**
   * edge entails a transition to "host" configuration
   *
   * @generated from field: optional bool cfg_is_host = 13;
   */
  cfgIsHost: boolean;
};

/**
 * Describes the message blaze_query.AttributeDefinition.
 * Use `create(AttributeDefinitionSchema)` to create a new message.
 */
export const AttributeDefinitionSchema: GenMessage<AttributeDefinition> = /*@__PURE__*/
  messageDesc(file_build, 18);

/**
 * An AttributeValue represents the value of an attribute.
 * A single field, determined by the attribute type, is populated.
 *
 * It is used only for AttributeDefinition.default. Attribute and
 * SelectorEntry do their own thing for unfortunate historical reasons.
 *
 * @generated from message blaze_query.AttributeValue
 */
export type AttributeValue = Message<"blaze_query.AttributeValue"> & {
  /**
   * type=int|tristate
   *
   * @generated from field: optional int32 int = 1;
   */
  int: number;

  /**
   * type=string|label|output
   *
   * @generated from field: optional string string = 2;
   */
  string: string;

  /**
   * type=bool
   *
   * @generated from field: optional bool bool = 3;
   */
  bool: boolean;

  /**
   * type=*_list|distrib
   *
   * @generated from field: repeated blaze_query.AttributeValue list = 4;
   */
  list: AttributeValue[];

  /**
   * type=*_dict
   *
   * @generated from field: repeated blaze_query.AttributeValue.DictEntry dict = 5;
   */
  dict: AttributeValue_DictEntry[];
};

/**
 * Describes the message blaze_query.AttributeValue.
 * Use `create(AttributeValueSchema)` to create a new message.
 */
export const AttributeValueSchema: GenMessage<AttributeValue> = /*@__PURE__*/
  messageDesc(file_build, 19);

/**
 * @generated from message blaze_query.AttributeValue.DictEntry
 */
export type AttributeValue_DictEntry = Message<"blaze_query.AttributeValue.DictEntry"> & {
  /**
   * @generated from field: required string key = 1;
   */
  key: string;

  /**
   * @generated from field: required blaze_query.AttributeValue value = 2;
   */
  value?: AttributeValue;
};

/**
 * Describes the message blaze_query.AttributeValue.DictEntry.
 * Use `create(AttributeValue_DictEntrySchema)` to create a new message.
 */
export const AttributeValue_DictEntrySchema: GenMessage<AttributeValue_DictEntry> = /*@__PURE__*/
  messageDesc(file_build, 19, 0);

/**
 * @generated from message blaze_query.RuleDefinition
 */
export type RuleDefinition = Message<"blaze_query.RuleDefinition"> & {
  /**
   * @generated from field: required string name = 1;
   */
  name: string;

  /**
   * Only contains documented attributes
   *
   * @generated from field: repeated blaze_query.AttributeDefinition attribute = 2;
   */
  attribute: AttributeDefinition[];

  /**
   * @generated from field: optional string documentation = 3;
   */
  documentation: string;

  /**
   * Only for build extensions: label to file that defines the extension
   *
   * @generated from field: optional string label = 4;
   */
  label: string;
};

/**
 * Describes the message blaze_query.RuleDefinition.
 * Use `create(RuleDefinitionSchema)` to create a new message.
 */
export const RuleDefinitionSchema: GenMessage<RuleDefinition> = /*@__PURE__*/
  messageDesc(file_build, 20);

/**
 * @generated from message blaze_query.BuildLanguage
 */
export type BuildLanguage = Message<"blaze_query.BuildLanguage"> & {
  /**
   * Only contains documented rule definitions
   *
   * @generated from field: repeated blaze_query.RuleDefinition rule = 1;
   */
  rule: RuleDefinition[];
};

/**
 * Describes the message blaze_query.BuildLanguage.
 * Use `create(BuildLanguageSchema)` to create a new message.
 */
export const BuildLanguageSchema: GenMessage<BuildLanguage> = /*@__PURE__*/
  messageDesc(file_build, 21);

